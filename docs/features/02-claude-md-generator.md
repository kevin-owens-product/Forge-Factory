# Feature: CLAUDE.md Generator

**Feature ID:** FF-002
**Version:** 1.0
**Status:** Draft
**Owner:** Engineering Team

---

## Overview

The CLAUDE.md Generator automatically creates AI agent constitution files that help Claude (and other AI coding assistants) understand project structure, conventions, and workflows. These files serve as "memory" for AI agents, improving their effectiveness dramatically.

### User Story
> As a **developer**, I want to **automatically generate a CLAUDE.md file for my repository** so that **AI coding assistants understand my project's conventions and can work more effectively**.

### Success Criteria
- ✓ Generated CLAUDE.md is under 200 lines
- ✓ Includes all essential sections (structure, commands, conventions, gotchas)
- ✓ Human-readable and editable
- ✓ Improves AI agent success rate by 40%+

---

## Vertical Slice Architecture

### 1. Database Schema

```sql
-- CLAUDE.md generation jobs
CREATE TABLE claude_md_jobs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  repository_id UUID NOT NULL REFERENCES repositories(id) ON DELETE CASCADE,
  status VARCHAR(20) NOT NULL CHECK (status IN ('pending', 'running', 'completed', 'failed')),
  content TEXT, -- Generated CLAUDE.md content
  version INTEGER DEFAULT 1,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  completed_at TIMESTAMPTZ,

  -- Generation settings
  settings JSONB DEFAULT '{
    "maxLines": 200,
    "sections": ["overview", "structure", "commands", "conventions", "testing", "gotchas"],
    "tone": "concise"
  }'::jsonb
);

CREATE INDEX idx_claude_md_jobs_repo ON claude_md_jobs(repository_id, created_at DESC);

-- Template library
CREATE TABLE claude_md_templates (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name VARCHAR(255) NOT NULL,
  description TEXT,
  framework VARCHAR(100), -- 'nextjs', 'react', 'django', 'express', etc.
  language VARCHAR(50),
  content TEXT NOT NULL,
  is_public BOOLEAN DEFAULT TRUE,
  usage_count INTEGER DEFAULT 0,
  created_by UUID REFERENCES users(id),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),

  UNIQUE(name, framework, language)
);

-- User customizations
CREATE TABLE claude_md_customizations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  repository_id UUID NOT NULL REFERENCES repositories(id) ON DELETE CASCADE,
  section VARCHAR(50) NOT NULL,
  content TEXT NOT NULL,
  order_index INTEGER DEFAULT 0,

  UNIQUE(repository_id, section)
);

CREATE INDEX idx_customizations_repo ON claude_md_customizations(repository_id);
```

### 2. API Endpoints

```typescript
// types/claude-md.ts
export interface ClaudeMdRequest {
  repositoryId: string;
  settings?: {
    maxLines?: number;
    sections?: string[];
    tone?: 'concise' | 'detailed' | 'friendly';
    includeExamples?: boolean;
  };
}

export interface ClaudeMdResponse {
  id: string;
  repositoryId: string;
  status: 'pending' | 'running' | 'completed' | 'failed';
  content?: string;
  version: number;
  createdAt: string;
  completedAt?: string;
}

export interface ClaudeMdSection {
  title: string;
  content: string;
  priority: number;
  autoGenerated: boolean;
}

export interface ClaudeMdTemplate {
  id: string;
  name: string;
  framework: string;
  language: string;
  content: string;
  usageCount: number;
}
```

```typescript
// routes/claude-md.ts
import { FastifyInstance } from 'fastify';
import { z } from 'zod';

const GenerateClaudeMdSchema = z.object({
  repositoryId: z.string().uuid(),
  settings: z.object({
    maxLines: z.number().min(50).max(500).optional(),
    sections: z.array(z.string()).optional(),
    tone: z.enum(['concise', 'detailed', 'friendly']).optional(),
    includeExamples: z.boolean().optional(),
  }).optional(),
});

export async function claudeMdRoutes(fastify: FastifyInstance) {

  // Generate CLAUDE.md
  fastify.post<{
    Body: ClaudeMdRequest;
  }>('/api/v1/claude-md/generate', {
    schema: {
      body: GenerateClaudeMdSchema,
    },
    preHandler: [fastify.authenticate, fastify.authorize(['repo:write'])],
  }, async (request, reply) => {
    const { repositoryId, settings } = request.body;

    const repository = await fastify.db.repository.findUnique({
      where: { id: repositoryId },
      include: {
        latestAnalysis: true,
      },
    });

    if (!repository) {
      return reply.code(404).send({ error: 'Repository not found' });
    }

    // Create generation job
    const job = await fastify.db.claudeMdJob.create({
      data: {
        repositoryId,
        status: 'pending',
        settings: settings || {},
      },
    });

    // Enqueue generation
    await fastify.queue.add('claude-md-generation', {
      jobId: job.id,
      repositoryId,
      analysisId: repository.latestAnalysis?.id,
    });

    return reply.code(201).send(job);
  });

  // Get generation status
  fastify.get<{
    Params: { id: string };
  }>('/api/v1/claude-md/:id', {
    preHandler: [fastify.authenticate],
  }, async (request, reply) => {
    const { id } = request.params;

    const job = await fastify.db.claudeMdJob.findUnique({
      where: { id },
    });

    if (!job) {
      return reply.code(404).send({ error: 'Job not found' });
    }

    return job;
  });

  // Get latest CLAUDE.md for repository
  fastify.get<{
    Params: { repositoryId: string };
  }>('/api/v1/repositories/:repositoryId/claude-md', {
    preHandler: [fastify.authenticate],
  }, async (request, reply) => {
    const { repositoryId } = request.params;

    const latestJob = await fastify.db.claudeMdJob.findFirst({
      where: {
        repositoryId,
        status: 'completed',
      },
      orderBy: { createdAt: 'desc' },
    });

    if (!latestJob) {
      return reply.code(404).send({ error: 'No CLAUDE.md generated yet' });
    }

    return latestJob;
  });

  // Update CLAUDE.md section
  fastify.patch<{
    Params: { repositoryId: string };
    Body: { section: string; content: string };
  }>('/api/v1/repositories/:repositoryId/claude-md/sections/:section', {
    preHandler: [fastify.authenticate, fastify.authorize(['repo:write'])],
  }, async (request, reply) => {
    const { repositoryId } = request.params;
    const { section, content } = request.body;

    const customization = await fastify.db.claudeMdCustomization.upsert({
      where: {
        repositoryId_section: {
          repositoryId,
          section,
        },
      },
      create: {
        repositoryId,
        section,
        content,
      },
      update: {
        content,
      },
    });

    // Trigger regeneration with customization
    await fastify.queue.add('claude-md-generation', {
      repositoryId,
      includeCustomizations: true,
    });

    return customization;
  });

  // List available templates
  fastify.get('/api/v1/claude-md/templates', {
    preHandler: [fastify.authenticate],
  }, async (request, reply) => {
    const templates = await fastify.db.claudeMdTemplate.findMany({
      where: { isPublic: true },
      orderBy: { usageCount: 'desc' },
    });

    return templates;
  });

  // Apply template
  fastify.post<{
    Body: {
      repositoryId: string;
      templateId: string;
    };
  }>('/api/v1/claude-md/apply-template', {
    preHandler: [fastify.authenticate, fastify.authorize(['repo:write'])],
  }, async (request, reply) => {
    const { repositoryId, templateId } = request.body;

    const template = await fastify.db.claudeMdTemplate.findUnique({
      where: { id: templateId },
    });

    if (!template) {
      return reply.code(404).send({ error: 'Template not found' });
    }

    // Create job with template
    const job = await fastify.db.claudeMdJob.create({
      data: {
        repositoryId,
        status: 'pending',
        settings: { templateId },
      },
    });

    // Increment usage count
    await fastify.db.claudeMdTemplate.update({
      where: { id: templateId },
      data: { usageCount: { increment: 1 } },
    });

    await fastify.queue.add('claude-md-generation', {
      jobId: job.id,
      repositoryId,
      templateId,
    });

    return reply.code(201).send(job);
  });
}
```

### 3. Generation Engine

```typescript
// services/claude-md-generator.ts
import Anthropic from '@anthropic-ai/sdk';

interface GenerationContext {
  repository: Repository;
  analysis?: AnalysisRun;
  template?: ClaudeMdTemplate;
  customizations?: ClaudeMdCustomization[];
}

export class ClaudeMdGenerator {
  constructor(
    private anthropic: Anthropic,
    private db: Database,
  ) {}

  async generate(jobId: string): Promise<string> {
    const job = await this.db.claudeMdJob.findUnique({
      where: { id: jobId },
      include: {
        repository: true,
      },
    });

    if (!job) {
      throw new Error('Job not found');
    }

    // Update status
    await this.db.claudeMdJob.update({
      where: { id: jobId },
      data: { status: 'running' },
    });

    try {
      // Gather context
      const context = await this.gatherContext(job);

      // Generate content
      const content = await this.generateContent(context, job.settings);

      // Validate
      this.validateContent(content, job.settings.maxLines || 200);

      // Store result
      await this.db.claudeMdJob.update({
        where: { id: jobId },
        data: {
          status: 'completed',
          content,
          completedAt: new Date(),
        },
      });

      // Create pull request
      await this.createPullRequest(job.repository, content);

      return content;
    } catch (error) {
      await this.db.claudeMdJob.update({
        where: { id: jobId },
        data: {
          status: 'failed',
          completedAt: new Date(),
        },
      });
      throw error;
    }
  }

  private async gatherContext(job: ClaudeMdJob): Promise<GenerationContext> {
    // Get repository structure
    const repoPath = await this.cloneRepository(job.repository);
    const structure = await this.analyzeStructure(repoPath);

    // Get package.json or equivalent
    const packageInfo = await this.getPackageInfo(repoPath);

    // Get recent commits for workflow understanding
    const commits = await this.getRecentCommits(job.repository, 50);

    // Get analysis results
    const analysis = await this.db.analysisRun.findFirst({
      where: { repositoryId: job.repository.id, status: 'completed' },
      orderBy: { createdAt: 'desc' },
    });

    // Get customizations
    const customizations = await this.db.claudeMdCustomization.findMany({
      where: { repositoryId: job.repository.id },
    });

    // Detect framework
    const framework = this.detectFramework(packageInfo, structure);

    // Get template if applicable
    let template: ClaudeMdTemplate | undefined;
    if (job.settings.templateId) {
      template = await this.db.claudeMdTemplate.findUnique({
        where: { id: job.settings.templateId },
      });
    } else if (framework) {
      template = await this.db.claudeMdTemplate.findFirst({
        where: { framework, isPublic: true },
        orderBy: { usageCount: 'desc' },
      });
    }

    return {
      repository: job.repository,
      structure,
      packageInfo,
      commits,
      analysis,
      customizations,
      framework,
      template,
    };
  }

  private async generateContent(context: GenerationContext, settings: any): Promise<string> {
    const prompt = this.buildPrompt(context, settings);

    const response = await this.anthropic.messages.create({
      model: 'claude-sonnet-4.5-20250929',
      max_tokens: 4096,
      messages: [{
        role: 'user',
        content: prompt,
      }],
    });

    const content = response.content[0].type === 'text'
      ? response.content[0].text
      : '';

    return this.postProcess(content, settings);
  }

  private buildPrompt(context: GenerationContext, settings: any): string {
    const { repository, structure, packageInfo, analysis, framework } = context;

    return `You are generating a CLAUDE.md file for an AI coding assistant.

## Repository Information
- Name: ${repository.name}
- Framework: ${framework || 'Unknown'}
- Languages: ${structure.languages.join(', ')}
- Total Files: ${structure.fileCount}

## Directory Structure
\`\`\`
${this.formatStructure(structure)}
\`\`\`

## Package Information
\`\`\`json
${JSON.stringify(packageInfo, null, 2)}
\`\`\`

## Analysis Results
${analysis ? `- AI-Readiness Score: ${analysis.aiReadinessScore}/100
- Test Coverage: ${analysis.testCoveragePercent}%
- Documentation: ${analysis.documentationPercent}%` : 'No analysis available'}

## Requirements
1. Keep content under ${settings.maxLines || 200} lines
2. Tone: ${settings.tone || 'concise'}
3. Include sections: ${settings.sections?.join(', ') || 'all'}
4. Focus on what AI agents commonly get wrong

## Template Structure
Generate a CLAUDE.md file with these sections:

### Project Overview
- Brief (2-3 sentences) description
- Tech stack
- Key architectural decisions

### Directory Structure
- Explain key directories (not exhaustive)
- Purpose of each important folder

### Development Commands
- How to install dependencies
- How to run development server
- How to run tests
- How to build for production

### Code Conventions
- File naming patterns
- Component/module structure
- Import order conventions
- Testing patterns

### Common Workflows
- How to add a new feature
- How to add a new API endpoint
- How to add a new page/component

### Things AI Often Gets Wrong
- Common pitfalls specific to this codebase
- Gotchas with the framework/libraries used
- Special considerations

## Important Guidelines
- Be concise - every line counts
- Focus on "why" not "what" (AI can see the code)
- Don't embed entire file contents
- Use examples sparingly
- Make it human-readable
- Avoid prohibitions without alternatives (say "use X" not "don't use Y")

Generate the CLAUDE.md content now:`;
  }

  private postProcess(content: string, settings: any): string {
    // Remove any markdown code fences around the entire content
    content = content.replace(/^```(?:markdown)?\n/gm, '');
    content = content.replace(/\n```$/gm, '');

    // Ensure consistent heading levels
    content = this.normalizeHeadings(content);

    // Trim to max lines if needed
    const lines = content.split('\n');
    const maxLines = settings.maxLines || 200;

    if (lines.length > maxLines) {
      // Intelligently trim - keep full sections
      content = this.intelligentTrim(lines, maxLines);
    }

    // Add metadata header
    const header = `# ${content.repository.name}

**Auto-generated by Forge Factory**
**Last updated:** ${new Date().toISOString()}
**Version:** ${content.version}

---

`;

    return header + content;
  }

  private intelligentTrim(lines: string[], maxLines: number): string {
    // Find section boundaries
    const sections: Array<{ start: number; end: number; title: string }> = [];
    let currentSection = { start: 0, end: 0, title: '' };

    lines.forEach((line, i) => {
      if (line.startsWith('## ')) {
        if (currentSection.title) {
          currentSection.end = i - 1;
          sections.push({ ...currentSection });
        }
        currentSection = { start: i, end: lines.length - 1, title: line };
      }
    });
    if (currentSection.title) {
      sections.push(currentSection);
    }

    // Priority order for sections
    const priorities = {
      'Project Overview': 1,
      'Directory Structure': 2,
      'Development Commands': 1,
      'Code Conventions': 2,
      'Things AI Often Gets Wrong': 1,
      'Common Workflows': 3,
    };

    // Sort sections by priority
    sections.sort((a, b) => {
      const priorityA = priorities[a.title.replace('## ', '')] || 4;
      const priorityB = priorities[b.title.replace('## ', '')] || 4;
      return priorityA - priorityB;
    });

    // Include sections until we hit max lines
    let includedLines = 0;
    const includedSections: typeof sections = [];

    for (const section of sections) {
      const sectionLength = section.end - section.start + 1;
      if (includedLines + sectionLength <= maxLines) {
        includedSections.push(section);
        includedLines += sectionLength;
      }
    }

    // Rebuild content with included sections in original order
    includedSections.sort((a, b) => a.start - b.start);

    const trimmedLines: string[] = [];
    includedSections.forEach(section => {
      trimmedLines.push(...lines.slice(section.start, section.end + 1));
    });

    return trimmedLines.join('\n');
  }

  private async createPullRequest(repository: Repository, content: string): Promise<void> {
    // Create branch
    const branchName = `forge-factory/claude-md-${Date.now()}`;

    // Commit CLAUDE.md
    await this.gitService.createBranch(repository, branchName);
    await this.gitService.commitFile(repository, branchName, 'CLAUDE.md', content);

    // Create PR
    await this.gitService.createPullRequest(repository, {
      title: 'Add CLAUDE.md for AI coding assistants',
      body: `This PR adds a CLAUDE.md file to help AI coding assistants understand this repository.

## What is CLAUDE.md?

CLAUDE.md serves as "memory" for AI coding assistants like Claude, Cursor, and GitHub Copilot. It documents:
- Project structure and conventions
- Development workflows
- Common pitfalls and gotchas

## Benefits

- More accurate AI-generated code
- Better context understanding
- Fewer hallucinations
- Consistent code style

## Next Steps

1. Review the content
2. Edit sections that need customization
3. Merge when ready

Generated by [Forge Factory](https://forge-factory.dev)`,
      head: branchName,
      base: repository.defaultBranch,
    });
  }

  private validateContent(content: string, maxLines: number): void {
    const lines = content.split('\n');

    if (lines.length > maxLines) {
      throw new Error(`Content exceeds maximum ${maxLines} lines`);
    }

    // Check for required sections
    const requiredSections = [
      'Project Overview',
      'Development Commands',
      'Code Conventions',
    ];

    for (const section of requiredSections) {
      if (!content.includes(`## ${section}`)) {
        throw new Error(`Missing required section: ${section}`);
      }
    }

    // Check for anti-patterns
    const antiPatterns = [
      { pattern: /```[\s\S]{500,}/g, message: 'Code blocks should be concise' },
      { pattern: /don't.*without/gi, message: 'Avoid prohibitions without alternatives' },
    ];

    for (const { pattern, message } of antiPatterns) {
      if (pattern.test(content)) {
        console.warn(`Warning: ${message}`);
      }
    }
  }
}
```

### 4. UI Components

```typescript
// components/ClaudeMdPreview.tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Copy, Download, Edit } from 'lucide-react';
import ReactMarkdown from 'react-markdown';

interface ClaudeMdPreviewProps {
  content: string;
  onEdit?: () => void;
}

export function ClaudeMdPreview({ content, onEdit }: ClaudeMdPreviewProps) {
  const [copied, setCopied] = useState(false);

  const handleCopy = async () => {
    await navigator.clipboard.writeText(content);
    setCopied(true);
    setTimeout(() => setCopied(false), 2000);
  };

  const handleDownload = () => {
    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'CLAUDE.md';
    a.click();
    URL.revokeObjectURL(url);
  };

  return (
    <div className="border rounded-lg">
      <div className="flex items-center justify-between p-4 border-b">
        <h3 className="font-semibold">CLAUDE.md</h3>
        <div className="flex gap-2">
          <Button variant="outline" size="sm" onClick={handleCopy}>
            <Copy className="h-4 w-4 mr-2" />
            {copied ? 'Copied!' : 'Copy'}
          </Button>
          <Button variant="outline" size="sm" onClick={handleDownload}>
            <Download className="h-4 w-4 mr-2" />
            Download
          </Button>
          {onEdit && (
            <Button variant="outline" size="sm" onClick={onEdit}>
              <Edit className="h-4 w-4 mr-2" />
              Edit
            </Button>
          )}
        </div>
      </div>

      <Tabs defaultValue="preview" className="p-4">
        <TabsList>
          <TabsTrigger value="preview">Preview</TabsTrigger>
          <TabsTrigger value="source">Source</TabsTrigger>
        </TabsList>

        <TabsContent value="preview" className="prose max-w-none">
          <ReactMarkdown>{content}</ReactMarkdown>
        </TabsContent>

        <TabsContent value="source">
          <pre className="bg-muted p-4 rounded-lg overflow-x-auto">
            <code>{content}</code>
          </pre>
        </TabsContent>
      </Tabs>
    </div>
  );
}

// components/ClaudeMdEditor.tsx
import { Editor } from '@monaco-editor/react';

interface ClaudeMdEditorProps {
  initialContent: string;
  onSave: (content: string) => void;
}

export function ClaudeMdEditor({ initialContent, onSave }: ClaudeMdEditorProps) {
  const [content, setContent] = useState(initialContent);
  const [lineCount, setLineCount] = useState(initialContent.split('\n').length);

  const handleChange = (value: string | undefined) => {
    if (value) {
      setContent(value);
      setLineCount(value.split('\n').length);
    }
  };

  const getLineCountColor = () => {
    if (lineCount <= 150) return 'text-green-600';
    if (lineCount <= 200) return 'text-yellow-600';
    return 'text-red-600';
  };

  return (
    <div className="border rounded-lg">
      <div className="flex items-center justify-between p-4 border-b">
        <div className="flex items-center gap-4">
          <h3 className="font-semibold">Edit CLAUDE.md</h3>
          <span className={`text-sm ${getLineCountColor()}`}>
            {lineCount} / 200 lines
          </span>
        </div>
        <Button onClick={() => onSave(content)}>
          Save Changes
        </Button>
      </div>

      <Editor
        height="600px"
        defaultLanguage="markdown"
        value={content}
        onChange={handleChange}
        theme="vs-dark"
        options={{
          minimap: { enabled: false },
          fontSize: 14,
          lineNumbers: 'on',
          wordWrap: 'on',
        }}
      />
    </div>
  );
}
```

### 5. Tests

```typescript
// tests/claude-md-generator.test.ts
import { describe, it, expect } from 'vitest';
import { ClaudeMdGenerator } from '@/services/claude-md-generator';
import { createMockRepository } from './fixtures';

describe('ClaudeMdGenerator', () => {
  it('generates valid CLAUDE.md', async () => {
    const generator = new ClaudeMdGenerator(mockAnthropic, mockDb);
    const repository = createMockRepository();

    const content = await generator.generate(repository.id);

    // Should be under 200 lines
    const lines = content.split('\n');
    expect(lines.length).toBeLessThanOrEqual(200);

    // Should include required sections
    expect(content).toContain('## Project Overview');
    expect(content).toContain('## Development Commands');
    expect(content).toContain('## Code Conventions');
  });

  it('respects max line limit', async () => {
    const generator = new ClaudeMdGenerator(mockAnthropic, mockDb);
    const repository = createMockRepository();

    const content = await generator.generate(repository.id, { maxLines: 100 });

    const lines = content.split('\n');
    expect(lines.length).toBeLessThanOrEqual(100);
  });

  it('applies template correctly', async () => {
    const generator = new ClaudeMdGenerator(mockAnthropic, mockDb);
    const repository = createMockRepository({ framework: 'nextjs' });

    const content = await generator.generate(repository.id);

    // Should include Next.js-specific content
    expect(content).toContain('Next.js');
  });
});
```

---

## Implementation Plan

- **Week 1:** Core generation engine + LLM integration
- **Week 2:** Template library + customization UI
- **Week 3:** PR creation + review workflow
- **Week 4:** Polish + documentation

---

## Success Metrics

- Generated files under 200 lines: 95%+
- Human approval rate: 80%+
- AI agent effectiveness improvement: 40%+

---

**Status:** Ready for implementation
