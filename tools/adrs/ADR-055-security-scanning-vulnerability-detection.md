# ADR-055: Security Scanning & Vulnerability Detection

**Status:** Accepted
**Date:** 2026-01-21
**Priority:** P1 - Enterprise Ready
**Complexity:** High

---

## Context

AI-generated code can introduce security vulnerabilities. Enterprise customers require comprehensive security scanning that detects OWASP Top 10, CWE categories, secrets exposure, and dependency vulnerabilities before any code reaches production.

### Business Requirements

- **Coverage:** OWASP Top 10, CWE Top 25, SANS Top 25
- **Speed:** Scan 100K LOC in <60 seconds
- **Integration:** Block PR merges on critical vulnerabilities
- **Compliance:** SOC 2, ISO 27001, HIPAA, PCI-DSS reporting
- **False Positives:** <5% false positive rate
- **Remediation:** Automated fix suggestions

### Vulnerability Categories

| Category | Examples | Severity |
|----------|----------|----------|
| Injection | SQL injection, Command injection, XSS | Critical |
| Authentication | Broken auth, Session fixation | Critical |
| Sensitive Data | Hardcoded secrets, Data exposure | High |
| Access Control | Broken access control, IDOR | High |
| Misconfiguration | Debug enabled, Default credentials | Medium |
| Dependencies | CVEs in npm/pip packages | Variable |
| Cryptography | Weak algorithms, Poor key management | High |

---

## Decision

We will implement a **multi-layer security scanning system** with:

1. **Static Application Security Testing (SAST)** - Source code analysis
2. **Secrets Detection** - Find hardcoded credentials
3. **Dependency Scanning** - CVE detection in dependencies
4. **Security Linting** - Language-specific security rules
5. **AI-Powered Analysis** - Semantic vulnerability detection

### Architecture Overview

```typescript
interface SecurityScanningSystem {
  // Scanning
  scan(code: SourceCode): Promise<SecurityScanResult>;
  scanRepository(repo: Repository): Promise<RepositoryScanResult>;
  scanPullRequest(pr: PullRequest): Promise<PRScanResult>;

  // Analysis
  analyzeVulnerability(finding: Finding): Promise<VulnerabilityAnalysis>;
  assessRisk(findings: Finding[]): Promise<RiskAssessment>;

  // Remediation
  suggestFix(finding: Finding): Promise<RemediationSuggestion>;
  autoFix(finding: Finding): Promise<AutoFixResult>;
}

interface SecurityScanResult {
  scanId: string;
  timestamp: Date;
  duration: number;

  findings: SecurityFinding[];
  summary: ScanSummary;
  compliance: ComplianceStatus;
}

interface SecurityFinding {
  id: string;
  type: FindingType;
  severity: 'critical' | 'high' | 'medium' | 'low' | 'info';
  confidence: number;

  // Location
  file: string;
  line: number;
  column: number;
  codeSnippet: string;

  // Details
  title: string;
  description: string;
  cwe: string[];
  owasp: string[];

  // Remediation
  remediation: string;
  references: string[];
  autoFixAvailable: boolean;
}
```

### Component 1: Static Application Security Testing (SAST)

Deep source code analysis for vulnerabilities.

```typescript
class SASTScanner {
  constructor(
    private semgrep: SemgrepClient,
    private codeql: CodeQLClient,
    private customRules: CustomRuleEngine
  ) {}

  async scan(code: SourceCode): Promise<SASTResult> {
    const findings: SecurityFinding[] = [];

    // Run Semgrep with security rules
    const semgrepResults = await this.runSemgrep(code);
    findings.push(...this.convertSemgrepFindings(semgrepResults));

    // Run CodeQL for deep analysis
    const codeqlResults = await this.runCodeQL(code);
    findings.push(...this.convertCodeQLFindings(codeqlResults));

    // Run custom rules
    const customResults = await this.runCustomRules(code);
    findings.push(...customResults);

    // Deduplicate findings
    const deduped = this.deduplicateFindings(findings);

    // Calculate severity scores
    const scored = this.scoreFindings(deduped);

    return {
      findings: scored,
      scannerVersions: {
        semgrep: this.semgrep.version,
        codeql: this.codeql.version,
      },
    };
  }

  private async runSemgrep(code: SourceCode): Promise<SemgrepResult> {
    return this.semgrep.scan({
      target: code.path,
      config: [
        'p/security-audit',
        'p/owasp-top-ten',
        'p/cwe-top-25',
        'p/secrets',
        'p/nodejs-security',
        'p/python-security',
      ],
      output: 'json',
      verbose: true,
    });
  }

  private async runCodeQL(code: SourceCode): Promise<CodeQLResult> {
    // Create CodeQL database
    const database = await this.codeql.createDatabase({
      language: code.language,
      source: code.path,
    });

    // Run security queries
    return this.codeql.runQueries(database, {
      suite: 'security-extended',
      severity: ['error', 'warning'],
    });
  }

  private convertSemgrepFindings(results: SemgrepResult): SecurityFinding[] {
    return results.findings.map(f => ({
      id: `semgrep-${f.check_id}-${f.fingerprint}`,
      type: this.mapSemgrepType(f.check_id),
      severity: this.mapSeverity(f.extra.severity),
      confidence: f.extra.confidence === 'HIGH' ? 0.9 : 0.7,

      file: f.path,
      line: f.start.line,
      column: f.start.col,
      codeSnippet: f.extra.lines,

      title: f.check_id.replace(/-/g, ' '),
      description: f.extra.message,
      cwe: f.extra.metadata?.cwe || [],
      owasp: f.extra.metadata?.owasp || [],

      remediation: f.extra.metadata?.fix || 'Review and fix manually',
      references: f.extra.metadata?.references || [],
      autoFixAvailable: !!f.extra.fix,
    }));
  }
}
```

### Component 2: Secrets Detection

Find hardcoded credentials and sensitive data.

```typescript
class SecretsScanner {
  private patterns: SecretPattern[] = [
    // AWS
    { name: 'AWS Access Key', pattern: /AKIA[0-9A-Z]{16}/, severity: 'critical' },
    { name: 'AWS Secret Key', pattern: /[A-Za-z0-9/+=]{40}/, context: 'aws_secret', severity: 'critical' },

    // API Keys
    { name: 'OpenAI API Key', pattern: /sk-[A-Za-z0-9]{48}/, severity: 'critical' },
    { name: 'Anthropic API Key', pattern: /sk-ant-[A-Za-z0-9-_]{40,}/, severity: 'critical' },
    { name: 'Stripe API Key', pattern: /sk_live_[A-Za-z0-9]{24,}/, severity: 'critical' },
    { name: 'GitHub Token', pattern: /ghp_[A-Za-z0-9]{36}/, severity: 'critical' },
    { name: 'GitLab Token', pattern: /glpat-[A-Za-z0-9-]{20}/, severity: 'critical' },

    // Database
    { name: 'Database URL', pattern: /(mysql|postgres|mongodb):\/\/[^:]+:[^@]+@/, severity: 'critical' },
    { name: 'Redis URL', pattern: /redis:\/\/[^:]+:[^@]+@/, severity: 'high' },

    // Private Keys
    { name: 'RSA Private Key', pattern: /-----BEGIN RSA PRIVATE KEY-----/, severity: 'critical' },
    { name: 'EC Private Key', pattern: /-----BEGIN EC PRIVATE KEY-----/, severity: 'critical' },
    { name: 'Generic Private Key', pattern: /-----BEGIN PRIVATE KEY-----/, severity: 'critical' },

    // Generic Secrets
    { name: 'Password in Code', pattern: /password\s*[:=]\s*["'][^"']{8,}["']/, severity: 'high' },
    { name: 'API Key Pattern', pattern: /api[_-]?key\s*[:=]\s*["'][^"']{16,}["']/, severity: 'high' },
    { name: 'Secret Pattern', pattern: /secret\s*[:=]\s*["'][^"']{8,}["']/, severity: 'high' },
  ];

  async scan(code: SourceCode): Promise<SecretsResult> {
    const findings: SecurityFinding[] = [];

    // Scan each file
    for (const file of code.files) {
      const content = await this.readFile(file);
      const fileFindings = this.scanContent(content, file);
      findings.push(...fileFindings);
    }

    // Run TruffleHog for additional detection
    const truffleFindings = await this.runTruffleHog(code.path);
    findings.push(...truffleFindings);

    // Verify findings (reduce false positives)
    const verified = await this.verifyFindings(findings);

    return { findings: verified };
  }

  private scanContent(content: string, file: string): SecurityFinding[] {
    const findings: SecurityFinding[] = [];
    const lines = content.split('\n');

    for (let lineNum = 0; lineNum < lines.length; lineNum++) {
      const line = lines[lineNum];

      for (const pattern of this.patterns) {
        const match = line.match(pattern.pattern);
        if (match) {
          // Check for false positive indicators
          if (this.isFalsePositive(line, match[0], pattern)) {
            continue;
          }

          findings.push({
            id: `secret-${pattern.name}-${file}-${lineNum}`,
            type: 'secret',
            severity: pattern.severity,
            confidence: this.calculateConfidence(match[0], pattern),

            file,
            line: lineNum + 1,
            column: match.index || 0,
            codeSnippet: this.maskSecret(line),

            title: `Hardcoded ${pattern.name}`,
            description: `Found potential ${pattern.name} in source code`,
            cwe: ['CWE-798', 'CWE-259'],
            owasp: ['A02:2021'],

            remediation: 'Move secret to environment variable or secrets manager',
            references: [
              'https://owasp.org/Top10/A02_2021-Cryptographic_Failures/',
            ],
            autoFixAvailable: true,
          });
        }
      }
    }

    return findings;
  }

  private isFalsePositive(line: string, match: string, pattern: SecretPattern): boolean {
    // Skip if in comment
    if (line.trim().startsWith('//') || line.trim().startsWith('#')) {
      return true;
    }

    // Skip if example/placeholder
    const placeholders = ['XXXX', 'YOUR_', 'EXAMPLE', 'PLACEHOLDER', 'TODO', '<', '>'];
    if (placeholders.some(p => match.toUpperCase().includes(p))) {
      return true;
    }

    // Skip if in test file
    if (line.includes('test') || line.includes('mock') || line.includes('fake')) {
      return true;
    }

    // Skip common false positives
    if (match === 'password' && line.includes('passwordField')) {
      return true;
    }

    return false;
  }

  private maskSecret(line: string): string {
    // Mask sensitive parts of the secret
    return line.replace(
      /(['"])[^'"]{8,}(['"])/g,
      (match, q1, q2) => `${q1}****REDACTED****${q2}`
    );
  }
}
```

### Component 3: Dependency Scanning

Scan for CVEs in project dependencies.

```typescript
class DependencyScanner {
  constructor(
    private snykClient: SnykClient,
    private npmAudit: NPMAuditClient,
    private osv: OSVClient
  ) {}

  async scan(repository: Repository): Promise<DependencyScanResult> {
    const findings: SecurityFinding[] = [];

    // Detect package managers
    const packageManagers = await this.detectPackageManagers(repository);

    for (const pm of packageManagers) {
      switch (pm.type) {
        case 'npm':
          findings.push(...await this.scanNPM(pm.path));
          break;
        case 'pip':
          findings.push(...await this.scanPip(pm.path));
          break;
        case 'maven':
          findings.push(...await this.scanMaven(pm.path));
          break;
        case 'go':
          findings.push(...await this.scanGo(pm.path));
          break;
      }
    }

    // Cross-reference with OSV database
    const osvFindings = await this.osv.query(findings);
    this.enrichWithOSV(findings, osvFindings);

    return {
      findings,
      dependencyCount: await this.countDependencies(repository),
      vulnerableCount: new Set(findings.map(f => f.dependency)).size,
    };
  }

  private async scanNPM(packageJsonPath: string): Promise<SecurityFinding[]> {
    // Run npm audit
    const auditResult = await this.npmAudit.audit(packageJsonPath);

    // Run Snyk for additional coverage
    const snykResult = await this.snykClient.test(packageJsonPath);

    const findings: SecurityFinding[] = [];

    for (const vuln of auditResult.vulnerabilities) {
      findings.push({
        id: `npm-${vuln.id}`,
        type: 'dependency',
        severity: this.mapNPMSeverity(vuln.severity),
        confidence: 1.0,

        file: packageJsonPath,
        line: 0,
        column: 0,
        codeSnippet: `"${vuln.name}": "${vuln.version}"`,

        title: `Vulnerable dependency: ${vuln.name}`,
        description: vuln.overview,
        cwe: vuln.cwe || [],
        owasp: ['A06:2021'],

        remediation: this.generateUpgradeAdvice(vuln),
        references: [vuln.url, ...vuln.references],
        autoFixAvailable: !!vuln.fixAvailable,

        // Dependency-specific fields
        dependency: vuln.name,
        currentVersion: vuln.version,
        fixedVersion: vuln.fixAvailable?.version,
        cve: vuln.cve,
        cvss: vuln.cvss,
      });
    }

    return findings;
  }

  private generateUpgradeAdvice(vuln: NPMVulnerability): string {
    if (vuln.fixAvailable) {
      return `Upgrade ${vuln.name} to version ${vuln.fixAvailable.version} or later`;
    }

    if (vuln.alternativePackages?.length > 0) {
      return `Consider switching to: ${vuln.alternativePackages.join(', ')}`;
    }

    return 'No fix available. Consider removing or isolating this dependency.';
  }

  private mapNPMSeverity(severity: string): SecurityFinding['severity'] {
    const map: Record<string, SecurityFinding['severity']> = {
      'critical': 'critical',
      'high': 'high',
      'moderate': 'medium',
      'low': 'low',
      'info': 'info',
    };
    return map[severity] || 'medium';
  }
}
```

### Component 4: Security Linting

Language-specific security rules.

```typescript
class SecurityLinter {
  private rules: Map<string, SecurityRule[]> = new Map();

  constructor() {
    this.loadRules();
  }

  private loadRules(): void {
    // JavaScript/TypeScript rules
    this.rules.set('javascript', [
      {
        id: 'js-xss-innerhtml',
        pattern: /\.innerHTML\s*=\s*(?!["'`])/,
        severity: 'high',
        title: 'Potential XSS via innerHTML',
        description: 'Setting innerHTML with dynamic content can lead to XSS',
        cwe: ['CWE-79'],
        owasp: ['A03:2021'],
        fix: 'Use textContent or sanitize input',
      },
      {
        id: 'js-eval',
        pattern: /\beval\s*\(/,
        severity: 'critical',
        title: 'Use of eval()',
        description: 'eval() can execute arbitrary code',
        cwe: ['CWE-94'],
        owasp: ['A03:2021'],
        fix: 'Avoid eval(). Use JSON.parse() for JSON, Function() for dynamic functions',
      },
      {
        id: 'js-document-write',
        pattern: /document\.write\s*\(/,
        severity: 'medium',
        title: 'Use of document.write()',
        description: 'document.write() can be used for XSS and causes performance issues',
        cwe: ['CWE-79'],
        owasp: ['A03:2021'],
        fix: 'Use DOM manipulation methods instead',
      },
      {
        id: 'js-no-csrf-protection',
        pattern: /fetch\s*\([^)]*\{[^}]*method:\s*['"]POST['"]/,
        severity: 'high',
        title: 'Missing CSRF protection',
        description: 'POST request without CSRF token',
        cwe: ['CWE-352'],
        owasp: ['A01:2021'],
        fix: 'Include CSRF token in request headers',
        checkContext: (code: string, match: RegExpMatchArray) => {
          // Check if CSRF token is included
          const fetchBlock = code.substring(match.index!, match.index! + 200);
          return !fetchBlock.includes('csrf') && !fetchBlock.includes('CSRF');
        },
      },
    ]);

    // Python rules
    this.rules.set('python', [
      {
        id: 'py-sql-injection',
        pattern: /cursor\.execute\s*\([^)]*%s|cursor\.execute\s*\([^)]*\.format\(/,
        severity: 'critical',
        title: 'SQL Injection vulnerability',
        description: 'String formatting in SQL queries can lead to injection',
        cwe: ['CWE-89'],
        owasp: ['A03:2021'],
        fix: 'Use parameterized queries with placeholders',
      },
      {
        id: 'py-pickle-load',
        pattern: /pickle\.loads?\s*\(/,
        severity: 'critical',
        title: 'Unsafe deserialization with pickle',
        description: 'pickle can execute arbitrary code on untrusted data',
        cwe: ['CWE-502'],
        owasp: ['A08:2021'],
        fix: 'Use JSON or other safe serialization formats',
      },
      {
        id: 'py-yaml-load',
        pattern: /yaml\.load\s*\([^)]*\)(?!\s*,\s*Loader)/,
        severity: 'high',
        title: 'Unsafe YAML loading',
        description: 'yaml.load without safe Loader can execute code',
        cwe: ['CWE-502'],
        owasp: ['A08:2021'],
        fix: 'Use yaml.safe_load() or specify Loader=yaml.SafeLoader',
      },
    ]);
  }

  async lint(code: SourceCode): Promise<SecurityFinding[]> {
    const findings: SecurityFinding[] = [];
    const rules = this.rules.get(code.language) || [];

    for (const file of code.files) {
      const content = await this.readFile(file);
      const lines = content.split('\n');

      for (const rule of rules) {
        for (let lineNum = 0; lineNum < lines.length; lineNum++) {
          const line = lines[lineNum];
          const match = line.match(rule.pattern);

          if (match) {
            // Check context if rule has context checker
            if (rule.checkContext && !rule.checkContext(content, match)) {
              continue;
            }

            findings.push({
              id: `lint-${rule.id}-${file}-${lineNum}`,
              type: 'security-lint',
              severity: rule.severity,
              confidence: 0.85,

              file,
              line: lineNum + 1,
              column: match.index || 0,
              codeSnippet: line.trim(),

              title: rule.title,
              description: rule.description,
              cwe: rule.cwe,
              owasp: rule.owasp,

              remediation: rule.fix,
              references: [],
              autoFixAvailable: !!rule.autoFix,
            });
          }
        }
      }
    }

    return findings;
  }
}
```

### Component 5: AI-Powered Security Analysis

Use LLMs for semantic vulnerability detection.

```typescript
class AISecurityAnalyzer {
  constructor(private llmClient: AnthropicClient) {}

  async analyze(code: SourceCode, context: SecurityContext): Promise<SecurityFinding[]> {
    const findings: SecurityFinding[] = [];

    // Analyze high-risk functions
    const riskFunctions = await this.identifyRiskFunctions(code);

    for (const func of riskFunctions) {
      const analysis = await this.analyzeFunction(func, context);
      findings.push(...analysis.findings);
    }

    return findings;
  }

  private async analyzeFunction(
    func: FunctionNode,
    context: SecurityContext
  ): Promise<FunctionSecurityAnalysis> {
    const prompt = `
Analyze this function for security vulnerabilities:

\`\`\`${func.language}
${func.code}
\`\`\`

Context:
- This function handles: ${context.dataTypes.join(', ')}
- Authentication required: ${context.requiresAuth}
- User input sources: ${context.inputSources.join(', ')}

Check for:
1. **Injection vulnerabilities** (SQL, Command, XSS, LDAP)
2. **Authentication/Authorization flaws**
3. **Sensitive data exposure**
4. **Input validation issues**
5. **Error handling that leaks information**
6. **Race conditions or TOCTOU**
7. **Cryptographic weaknesses**
8. **Access control issues**

Return JSON array of findings (empty if secure):
[
  {
    "severity": "critical|high|medium|low",
    "title": "Short title",
    "description": "Detailed description",
    "line": <line number>,
    "cwe": ["CWE-XXX"],
    "owasp": ["A0X:2021"],
    "remediation": "How to fix",
    "confidence": <0-1>
  }
]
`;

    const response = await this.llmClient.complete({
      model: 'claude-sonnet-4-5',
      messages: [{ role: 'user', content: prompt }],
      max_tokens: 2000,
      temperature: 0,
    });

    return this.parseAnalysisResponse(response.content, func);
  }

  private async identifyRiskFunctions(code: SourceCode): Promise<FunctionNode[]> {
    const riskIndicators = [
      // Input handling
      'request.', 'req.body', 'req.params', 'req.query',
      'input()', 'sys.argv', 'os.environ',

      // Database
      'query', 'execute', 'cursor', 'sql',

      // File operations
      'readFile', 'writeFile', 'open(', 'os.path',

      // Command execution
      'exec', 'spawn', 'subprocess', 'os.system',

      // Authentication
      'password', 'token', 'session', 'auth',

      // Crypto
      'encrypt', 'decrypt', 'hash', 'sign',
    ];

    const functions = await this.extractFunctions(code);

    return functions.filter(func => {
      const funcCode = func.code.toLowerCase();
      return riskIndicators.some(indicator => funcCode.includes(indicator.toLowerCase()));
    });
  }
}
```

### Security Scan Orchestrator

```typescript
class SecurityScanOrchestrator {
  constructor(
    private sast: SASTScanner,
    private secrets: SecretsScanner,
    private dependencies: DependencyScanner,
    private linter: SecurityLinter,
    private ai: AISecurityAnalyzer
  ) {}

  async scanRepository(repo: Repository): Promise<RepositoryScanResult> {
    const startTime = Date.now();

    // Run all scanners in parallel
    const [
      sastResult,
      secretsResult,
      depsResult,
      lintResult,
    ] = await Promise.all([
      this.sast.scan(repo.code),
      this.secrets.scan(repo.code),
      this.dependencies.scan(repo),
      this.linter.lint(repo.code),
    ]);

    // Combine findings
    let allFindings = [
      ...sastResult.findings,
      ...secretsResult.findings,
      ...depsResult.findings,
      ...lintResult,
    ];

    // Run AI analysis on high-risk areas
    const highRiskFiles = this.identifyHighRiskFiles(allFindings);
    const aiFindings = await this.ai.analyze(
      { files: highRiskFiles, language: repo.language },
      { dataTypes: repo.dataTypes, requiresAuth: true, inputSources: repo.inputSources }
    );

    allFindings = [...allFindings, ...aiFindings];

    // Deduplicate and prioritize
    const dedupedFindings = this.deduplicateFindings(allFindings);
    const prioritizedFindings = this.prioritizeFindings(dedupedFindings);

    // Generate compliance report
    const compliance = this.assessCompliance(prioritizedFindings);

    return {
      scanId: generateId(),
      repository: repo.name,
      timestamp: new Date(),
      duration: Date.now() - startTime,

      findings: prioritizedFindings,
      summary: this.generateSummary(prioritizedFindings),
      compliance,

      recommendations: this.generateRecommendations(prioritizedFindings),
    };
  }

  private generateSummary(findings: SecurityFinding[]): ScanSummary {
    return {
      total: findings.length,
      bySeverity: {
        critical: findings.filter(f => f.severity === 'critical').length,
        high: findings.filter(f => f.severity === 'high').length,
        medium: findings.filter(f => f.severity === 'medium').length,
        low: findings.filter(f => f.severity === 'low').length,
        info: findings.filter(f => f.severity === 'info').length,
      },
      byType: this.groupByCounts(findings, 'type'),
      byCWE: this.groupByCounts(findings, 'cwe'),
      byOWASP: this.groupByCounts(findings, 'owasp'),
      autoFixable: findings.filter(f => f.autoFixAvailable).length,
    };
  }

  private assessCompliance(findings: SecurityFinding[]): ComplianceStatus {
    return {
      soc2: this.assessSOC2(findings),
      iso27001: this.assessISO27001(findings),
      hipaa: this.assessHIPAA(findings),
      pciDss: this.assessPCIDSS(findings),
    };
  }
}
```

---

## Consequences

### Positive

1. **Prevention:** Catch vulnerabilities before production
2. **Compliance:** Meet regulatory requirements
3. **Automation:** Reduce manual security review burden
4. **Education:** Developers learn from remediation suggestions
5. **Speed:** Fast feedback in CI/CD pipeline

### Negative

1. **False Positives:** Some valid code flagged
2. **Performance:** Scanning adds CI/CD time
3. **Complexity:** Multiple tools to configure and maintain
4. **Coverage Gaps:** No scanner catches everything

### Trade-offs

- **Thoroughness vs. Speed:** More scanners = slower but safer
- **Sensitivity vs. Noise:** High sensitivity = more false positives
- **Automation vs. Accuracy:** AI analysis is accurate but slower

---

## Implementation Plan

### Phase 1: SAST Integration (Week 1-2)
- Integrate Semgrep
- Configure CodeQL
- Build custom rules

### Phase 2: Secrets & Dependencies (Week 3-4)
- Implement secrets scanner
- Integrate dependency scanning
- Build CVE tracking

### Phase 3: Security Linting (Week 5-6)
- Create language-specific rules
- Build false positive filtering
- Add auto-fix suggestions

### Phase 4: AI Analysis (Week 7-8)
- Implement AI security analyzer
- Build risk prioritization
- Add compliance reporting

---

## References

- [OWASP Top 10](https://owasp.org/Top10/)
- [CWE Top 25](https://cwe.mitre.org/top25/)
- [Semgrep](https://semgrep.dev/)
- [Snyk](https://snyk.io/)
- [CodeQL](https://codeql.github.com/)

---

**Decision Maker:** Security Lead + Engineering Lead
**Approved By:** CISO
**Implementation Owner:** Security Engineering Team
