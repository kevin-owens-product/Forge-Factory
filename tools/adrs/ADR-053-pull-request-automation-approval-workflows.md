# ADR-053: Pull Request Automation & Approval Workflows

**Status:** Accepted
**Date:** 2026-01-21
**Priority:** P0 - Critical for Launch
**Complexity:** High
**Dependencies:** ADR-040 (Safety & Rollback), ADR-047 (Refactoring Engine), ADR-052 (Multi-Provider Source Control)

---

## Context

Forge Factory's automated code transformations must be **delivered to customers via Pull Requests** to enable human review, discussion, and approval before merging into production. The PR workflow is critical for:

- **Trust & Safety:** Developers review changes before they affect production
- **Collaboration:** Team discussion on transformation approach
- **Auditability:** Complete trail of what changed, why, and who approved
- **Education:** Developers learn from AI-generated transformations
- **Quality:** Catch edge cases or unintended consequences

### Business Requirements

**PR Creation:**
- Automatically create PRs after successful transformations
- Generate comprehensive PR descriptions (summary, changes, test plan)
- Include before/after metrics (AI-readiness score improvement)
- Link to transformation job for debugging
- Support draft PRs for review-before-ready

**PR Content:**
- Clear title: "Forge Factory: [Transformation Type] - [Improvement]"
- Structured body: Summary, Changes, Test Plan, Metrics
- Code comments on complex changes
- Checkboxes for manual verification steps
- Links to documentation and support

**Approval Workflow:**
- Configurable approval requirements (1-N reviewers)
- Auto-merge when approved (optional)
- Integration with CI/CD pipelines
- Status checks for transformation safety
- Notifications to reviewers (email, Slack)

**Merge Strategies:**
- Squash merge (default): Clean commit history
- Merge commit: Preserve transformation history
- Rebase: Linear history
- Respect repository branch protection rules

### User Personas

**1. Solo Developer (Indie SaaS, Startups)**
- Wants: Fast iteration, minimal friction
- Preference: Auto-merge after CI passes
- Risk tolerance: High (owns the codebase)

**2. Small Team (5-10 developers)**
- Wants: Quick review by 1 team member
- Preference: PR notifications, manual merge
- Risk tolerance: Medium

**3. Enterprise Team (50+ developers)**
- Wants: Multiple reviewers, compliance checks
- Preference: Strict approval workflow, audit trail
- Risk tolerance: Low (regulated industry, production-critical)

### Real-World PR Example

**Title:**
```
Forge Factory: File Split - Reduce auth.ts from 850 to 7 focused modules
```

**Body:**
````markdown
## Summary

This transformation splits the large `src/auth/auth.ts` file (850 LOC) into 7 focused modules to improve AI-readiness and maintainability.

## Changes

### Files Modified
- `src/auth/auth.ts` ‚Üí Removed (replaced by modules below)

### Files Created
- `src/auth/login-handler.ts` (100 LOC) - Main login endpoint handler
- `src/auth/validators/login-input-validator.ts` (80 LOC) - Input validation logic
- `src/auth/services/user-lookup-service.ts` (100 LOC) - User database queries
- `src/auth/services/password-service.ts` (120 LOC) - Password hashing and verification
- `src/auth/services/session-service.ts` (90 LOC) - Session creation and management
- `src/auth/audit/login-logger.ts` (60 LOC) - Audit logging
- `src/auth/formatters/login-response-formatter.ts` (50 LOC) - Response formatting

### AI-Readiness Impact

| Metric | Before | After | Change |
|--------|--------|-------|--------|
| **Overall Score** | 35 | 78 | +43 ‚úÖ |
| **Largest File** | 850 LOC | 120 LOC | -730 ‚úÖ |
| **Avg File Size** | 420 LOC | 86 LOC | -334 ‚úÖ |
| **Functions >50 LOC** | 45% | 8% | -37% ‚úÖ |
| **Complexity Score** | 45/100 | 85/100 | +40 ‚úÖ |

## Test Plan

All existing tests pass without modification. Please verify:

- [ ] Login flow works as expected (manual test)
- [ ] Password validation still rejects weak passwords
- [ ] Session creation generates valid JWT tokens
- [ ] Audit logs capture all login events
- [ ] Error handling preserves original behavior

## Transformation Details

- **Type:** File Split
- **Triggered by:** AI-Readiness Assessment (score below 40)
- **Job ID:** `job_abc123def456`
- **View job details:** https://app.forge-factory.dev/jobs/abc123def456

## Deployment Safety

- ‚úÖ All 127 existing tests pass
- ‚úÖ TypeScript compilation successful
- ‚úÖ ESLint: 0 new warnings
- ‚úÖ No security vulnerabilities introduced
- ‚úÖ Behavior preserved (AST diff validation)

---

**Generated by [Forge Factory](https://forge-factory.dev)** | [Documentation](https://docs.forge-factory.dev) | [Support](mailto:support@forge-factory.dev)
````

**File-Level Comments:**
```typescript
// src/auth/services/password-service.ts

// üí° Forge Factory: Extracted password logic into dedicated service
// This improves testability and follows Single Responsibility Principle.
// Original function was 100+ LOC with complexity score of 15.

export async function verifyPassword(user: User, password: string): Promise<void> {
  // ... implementation
}
```

---

## Decision

We will implement an **automated PR workflow system** with:

1. **PR Template Engine** (generate rich, informative PR descriptions)
2. **Multi-Provider PR Creation** (GitHub, GitLab, Bitbucket, Azure DevOps)
3. **Configurable Approval Rules** (0-N reviewers, auto-merge, CI gates)
4. **Status Check Integration** (report transformation safety)
5. **Notification System** (email, Slack, Teams, Discord)
6. **Merge Automation** (auto-merge when approved)
7. **Post-Merge Actions** (cleanup branches, track success)

### Architecture Overview

```typescript
interface PRAutomationEngine {
  // PR creation
  createPR(transformation: Transformation, options: PROptions): Promise<PullRequest>;
  generatePRDescription(transformation: Transformation): Promise<PRDescription>;
  addPRComments(pr: PullRequest, comments: CodeComment[]): Promise<void>;

  // Status checks
  createStatusCheck(pr: PullRequest, status: TransformationStatus): Promise<void>;
  updateStatusCheck(pr: PullRequest, status: TransformationStatus): Promise<void>;

  // Approval workflow
  requestReviewers(pr: PullRequest, reviewers: string[]): Promise<void>;
  waitForApproval(pr: PullRequest, options: ApprovalOptions): Promise<ApprovalResult>;
  autoMerge(pr: PullRequest, strategy: MergeStrategy): Promise<void>;

  // Notifications
  notifyReviewers(pr: PullRequest, channel: NotificationChannel): Promise<void>;
  notifyOnMerge(pr: PullRequest): Promise<void>;

  // Post-merge
  deleteBranch(pr: PullRequest): Promise<void>;
  trackPRSuccess(pr: PullRequest): Promise<void>;
}
```

### Core Component 1: PR Template Engine

```typescript
class PRTemplateEngine {
  async generatePRDescription(
    transformation: Transformation,
    result: RefactoringResult
  ): Promise<PRDescription> {
    const summary = this.generateSummary(transformation, result);
    const changes = this.generateChangesSection(result);
    const metrics = this.generateMetricsTable(transformation, result);
    const testPlan = this.generateTestPlan(transformation);
    const safetyChecks = this.generateSafetyChecks(result);

    return {
      title: this.generateTitle(transformation, result),
      body: this.buildMarkdown({
        summary,
        changes,
        metrics,
        testPlan,
        transformationDetails: this.generateTransformationDetails(transformation),
        safetyChecks,
        footer: this.generateFooter(),
      }),
    };
  }

  private generateTitle(
    transformation: Transformation,
    result: RefactoringResult
  ): string {
    const prefix = 'Forge Factory';
    const type = this.humanizeTransformationType(transformation.type);
    const improvement = this.summarizeImprovement(result);

    return `${prefix}: ${type} - ${improvement}`;
  }

  private humanizeTransformationType(type: RefactoringType): string {
    const humanNames: Record<RefactoringType, string> = {
      [RefactoringType.FILE_SPLIT]: 'File Split',
      [RefactoringType.EXTRACT_FUNCTION]: 'Extract Function',
      [RefactoringType.REDUCE_COMPLEXITY]: 'Reduce Complexity',
      [RefactoringType.ADD_TYPES]: 'Add Type Annotations',
      [RefactoringType.GENERATE_TESTS]: 'Generate Tests',
      [RefactoringType.ADD_DOCUMENTATION]: 'Add Documentation',
    };

    return humanNames[type] || type;
  }

  private summarizeImprovement(result: RefactoringResult): string {
    if (result.filesCreated > 0) {
      return `Split into ${result.filesCreated} focused modules`;
    }

    if (result.functionsExtracted > 0) {
      return `Extracted ${result.functionsExtracted} functions`;
    }

    if (result.complexityReduction > 0) {
      return `Reduced complexity by ${result.complexityReduction} points`;
    }

    return 'Improved AI-readiness';
  }

  private generateSummary(
    transformation: Transformation,
    result: RefactoringResult
  ): string {
    const templates: Record<RefactoringType, (t: Transformation, r: RefactoringResult) => string> = {
      [RefactoringType.FILE_SPLIT]: (t, r) =>
        `This transformation splits the large \`${t.affectedFiles[0].path}\` file (${t.affectedFiles[0].linesOfCode} LOC) into ${r.filesCreated} focused modules to improve AI-readiness and maintainability.`,

      [RefactoringType.EXTRACT_FUNCTION]: (t, r) =>
        `This transformation extracts ${r.functionsExtracted} complex functions into smaller, single-purpose functions to reduce cognitive complexity.`,

      [RefactoringType.REDUCE_COMPLEXITY]: (t, r) =>
        `This transformation simplifies control flow in ${t.affectedFiles.length} files, reducing average cyclomatic complexity by ${r.complexityReduction} points.`,

      [RefactoringType.ADD_TYPES]: (t, r) =>
        `This transformation adds type annotations to ${r.functionsAnnotated} functions, improving type safety and IDE support.`,

      [RefactoringType.GENERATE_TESTS]: (t, r) =>
        `This transformation generates ${r.testsCreated} unit tests for previously uncovered functions, increasing test coverage to ${r.newCoverage}%.`,

      [RefactoringType.ADD_DOCUMENTATION]: (t, r) =>
        `This transformation adds comprehensive JSDoc/docstrings to ${r.functionsDocumented} functions, improving code comprehension for AI agents and developers.`,
    };

    const template = templates[transformation.type];
    return template ? template(transformation, result) : 'Automated code transformation by Forge Factory.';
  }

  private generateChangesSection(result: RefactoringResult): string {
    const sections: string[] = [];

    // Files Modified
    if (result.filesModified > 0) {
      sections.push(`### Files Modified\n${this.listModifiedFiles(result)}`);
    }

    // Files Created
    if (result.filesCreated > 0) {
      sections.push(`### Files Created\n${this.listCreatedFiles(result)}`);
    }

    // Files Deleted
    if (result.filesDeleted > 0) {
      sections.push(`### Files Deleted\n${this.listDeletedFiles(result)}`);
    }

    return sections.join('\n\n');
  }

  private listCreatedFiles(result: RefactoringResult): string {
    return result.newFiles
      .map(file => `- \`${file.path}\` (${file.linesOfCode} LOC) - ${file.description}`)
      .join('\n');
  }

  private generateMetricsTable(
    transformation: Transformation,
    result: RefactoringResult
  ): string {
    const before = transformation.metrics.before;
    const after = transformation.metrics.after;

    const rows = [
      this.metricsRow('Overall Score', before.aiReadinessScore, after.aiReadinessScore, 'higher'),
      this.metricsRow('Largest File', before.largestFile, after.largestFile, 'lower', 'LOC'),
      this.metricsRow('Avg File Size', before.avgFileSize, after.avgFileSize, 'lower', 'LOC'),
      this.metricsRow('Functions >50 LOC', before.largeFunctions, after.largeFunctions, 'lower', '%'),
      this.metricsRow('Complexity Score', before.complexityScore, after.complexityScore, 'higher'),
    ];

    return `
| Metric | Before | After | Change |
|--------|--------|-------|--------|
${rows.join('\n')}
    `.trim();
  }

  private metricsRow(
    label: string,
    before: number,
    after: number,
    betterDirection: 'higher' | 'lower',
    unit: string = ''
  ): string {
    const delta = after - before;
    const isImprovement =
      (betterDirection === 'higher' && delta > 0) ||
      (betterDirection === 'lower' && delta < 0);

    const emoji = isImprovement ? '‚úÖ' : delta === 0 ? '‚ûñ' : '‚ö†Ô∏è';
    const sign = delta > 0 ? '+' : '';

    return `| **${label}** | ${before}${unit} | ${after}${unit} | ${sign}${delta}${unit} ${emoji} |`;
  }

  private generateTestPlan(transformation: Transformation): string {
    const tasks: string[] = [
      'All existing tests pass without modification',
      'Please verify:',
      '',
    ];

    // Add transformation-specific checks
    const checksByType: Record<RefactoringType, string[]> = {
      [RefactoringType.FILE_SPLIT]: [
        'Imports resolve correctly in all files',
        'No circular dependencies introduced',
        'All exported functions remain accessible',
      ],
      [RefactoringType.EXTRACT_FUNCTION]: [
        'Extracted functions preserve original behavior',
        'Function signatures are logical and well-typed',
        'No duplicate code remains',
      ],
      [RefactoringType.REDUCE_COMPLEXITY]: [
        'Simplified logic produces same outputs',
        'Edge cases still handled correctly',
        'Error handling remains intact',
      ],
      [RefactoringType.ADD_TYPES]: [
        'TypeScript compilation successful',
        'No type errors introduced',
        'Type coverage increased',
      ],
      [RefactoringType.GENERATE_TESTS]: [
        'Generated tests pass',
        'Test coverage increased',
        'Tests cover edge cases',
      ],
      [RefactoringType.ADD_DOCUMENTATION]: [
        'Documentation accurately describes behavior',
        'Examples are correct',
        'JSDoc/docstrings render properly',
      ],
    };

    const checks = checksByType[transformation.type] || ['Manual verification recommended'];

    checks.forEach(check => {
      tasks.push(`- [ ] ${check}`);
    });

    return tasks.join('\n');
  }

  private generateSafetyChecks(result: RefactoringResult): string {
    const checks = [
      { label: `All ${result.testResults.total} existing tests pass`, passed: result.testResults.passed },
      { label: 'TypeScript compilation successful', passed: result.compilationSuccessful },
      { label: `ESLint: ${result.lintResults.newWarnings} new warnings`, passed: result.lintResults.newWarnings === 0 },
      { label: 'No security vulnerabilities introduced', passed: result.securityScanPassed },
      { label: 'Behavior preserved (AST diff validation)', passed: result.behaviorPreserved },
    ];

    return checks
      .map(check => `- ${check.passed ? '‚úÖ' : '‚ùå'} ${check.label}`)
      .join('\n');
  }

  private generateTransformationDetails(transformation: Transformation): string {
    return `
- **Type:** ${this.humanizeTransformationType(transformation.type)}
- **Triggered by:** ${transformation.trigger}
- **Job ID:** \`${transformation.jobId}\`
- **View job details:** ${this.getJobUrl(transformation.jobId)}
    `.trim();
  }

  private generateFooter(): string {
    return `
---

**Generated by [Forge Factory](https://forge-factory.dev)** | [Documentation](https://docs.forge-factory.dev) | [Support](mailto:support@forge-factory.dev)
    `.trim();
  }

  private buildMarkdown(sections: Record<string, string>): string {
    return `
## Summary

${sections.summary}

## Changes

${sections.changes}

### AI-Readiness Impact

${sections.metrics}

## Test Plan

${sections.testPlan}

## Transformation Details

${sections.transformationDetails}

## Deployment Safety

${sections.safetyChecks}

${sections.footer}
    `.trim();
  }
}
```

### Core Component 2: PR Creation Orchestrator

```typescript
class PRCreationOrchestrator {
  async createPR(
    transformation: Transformation,
    result: RefactoringResult,
    options: PROptions
  ): Promise<PullRequest> {
    // 1. Get Git provider
    const provider = await this.getGitProvider(transformation.repository);

    // 2. Create branch (if not already created)
    const branch = await this.ensureBranch(provider, transformation);

    // 3. Commit changes
    await this.commitChanges(provider, transformation, result, branch);

    // 4. Generate PR description
    const prDescription = await this.templateEngine.generatePRDescription(
      transformation,
      result
    );

    // 5. Create pull request
    const pr = await provider.createPullRequest(transformation.repository, {
      title: prDescription.title,
      body: prDescription.body,
      head: branch.name,
      base: transformation.repository.defaultBranch,
      draft: options.draft || false,
    });

    // 6. Add code comments (for complex changes)
    if (options.addComments) {
      await this.addCodeComments(provider, pr, result);
    }

    // 7. Create status check
    await this.createStatusCheck(provider, pr, {
      state: 'success',
      context: 'Forge Factory / Transformation',
      description: 'Transformation completed successfully',
      targetUrl: this.getJobUrl(transformation.jobId),
    });

    // 8. Request reviewers (if configured)
    if (options.reviewers && options.reviewers.length > 0) {
      await this.requestReviewers(provider, pr, options.reviewers);
    }

    // 9. Notify reviewers
    await this.notifyReviewers(pr, options.notificationChannels || ['email']);

    // 10. Track PR
    await this.trackPR(pr, transformation);

    return pr;
  }

  private async ensureBranch(
    provider: GitProvider,
    transformation: Transformation
  ): Promise<Branch> {
    const branchName = this.generateBranchName(transformation);

    try {
      // Check if branch exists
      const branches = await provider.listBranches(transformation.repository);
      const existing = branches.find(b => b.name === branchName);

      if (existing) {
        return existing;
      }

      // Create new branch
      return await provider.createBranch(
        transformation.repository,
        branchName,
        transformation.repository.defaultBranch
      );
    } catch (error) {
      throw new Error(`Failed to create branch: ${error.message}`);
    }
  }

  private generateBranchName(transformation: Transformation): string {
    const type = transformation.type.replace(/_/g, '-').toLowerCase();
    const timestamp = Date.now();

    return `forge-factory/${type}-${timestamp}`;
  }

  private async commitChanges(
    provider: GitProvider,
    transformation: Transformation,
    result: RefactoringResult,
    branch: Branch
  ): Promise<void> {
    // Prepare commit message
    const commitMessage = this.generateCommitMessage(transformation, result);

    // Prepare file changes
    const files = result.changes.map(change => ({
      path: change.path,
      content: change.content,
    }));

    // Create commit
    await provider.createCommit(transformation.repository, {
      branch: branch.name,
      message: commitMessage,
      files,
    });
  }

  private generateCommitMessage(
    transformation: Transformation,
    result: RefactoringResult
  ): string {
    const type = this.templateEngine.humanizeTransformationType(transformation.type);
    const summary = this.templateEngine.summarizeImprovement(result);

    return `
${type}: ${summary}

Automated transformation by Forge Factory
Job ID: ${transformation.jobId}

Changes:
- Files created: ${result.filesCreated}
- Files modified: ${result.filesModified}
- Files deleted: ${result.filesDeleted}

AI-Readiness improvement: ${transformation.metrics.before.aiReadinessScore} ‚Üí ${transformation.metrics.after.aiReadinessScore}
    `.trim();
  }

  private async addCodeComments(
    provider: GitProvider,
    pr: PullRequest,
    result: RefactoringResult
  ): Promise<void> {
    // Add explanatory comments on complex changes
    for (const change of result.changes) {
      if (change.requiresExplanation) {
        await provider.addPRComment(pr.repository, pr.number, {
          path: change.path,
          line: change.line,
          body: change.explanation,
        });
      }
    }
  }

  private async requestReviewers(
    provider: GitProvider,
    pr: PullRequest,
    reviewers: string[]
  ): Promise<void> {
    // Note: Implementation depends on provider
    // GitHub: uses requestReviewers API
    // GitLab: assigns users to MR
    // Bitbucket: adds default reviewers

    if (provider.type === ProviderType.GITHUB) {
      await provider.requestReviewers(pr.repository, pr.number, reviewers);
    }
  }
}
```

### Core Component 3: Approval Workflow Manager

```typescript
class ApprovalWorkflowManager {
  async waitForApproval(
    pr: PullRequest,
    options: ApprovalOptions
  ): Promise<ApprovalResult> {
    const startTime = Date.now();
    const timeout = options.timeout || 24 * 60 * 60 * 1000; // 24 hours default

    while (Date.now() - startTime < timeout) {
      // Check approval status
      const status = await this.checkApprovalStatus(pr);

      if (status.approved) {
        return {
          approved: true,
          approvedBy: status.approvers,
          approvedAt: new Date(),
        };
      }

      if (status.changesRequested) {
        return {
          approved: false,
          changesRequested: true,
          feedback: status.feedback,
        };
      }

      if (status.rejected) {
        return {
          approved: false,
          rejected: true,
          reason: status.rejectionReason,
        };
      }

      // Wait before checking again
      await this.sleep(options.pollInterval || 60000); // 1 minute
    }

    // Timeout reached
    return {
      approved: false,
      timeout: true,
    };
  }

  private async checkApprovalStatus(pr: PullRequest): Promise<ApprovalStatus> {
    const provider = await this.getGitProvider(pr.repository);

    // Get PR reviews
    const reviews = await provider.getPRReviews(pr.repository, pr.number);

    // Determine status based on reviews
    const approvals = reviews.filter(r => r.state === 'APPROVED');
    const changesRequested = reviews.filter(r => r.state === 'CHANGES_REQUESTED');
    const rejections = reviews.filter(r => r.state === 'REJECTED');

    // Check if approval requirements met
    const requiredApprovals = await this.getRequiredApprovals(pr);

    return {
      approved: approvals.length >= requiredApprovals,
      approvers: approvals.map(a => a.user.login),
      changesRequested: changesRequested.length > 0,
      feedback: changesRequested.map(r => r.body),
      rejected: rejections.length > 0,
      rejectionReason: rejections[0]?.body,
    };
  }

  private async getRequiredApprovals(pr: PullRequest): Promise<number> {
    // Check repository settings or customer configuration
    const config = await this.db.prConfigs.findFirst({
      where: {
        repositoryId: pr.repository.id,
      },
    });

    return config?.requiredApprovals || 1; // Default: 1 approval
  }

  async autoMerge(
    pr: PullRequest,
    strategy: MergeStrategy = MergeStrategy.SQUASH
  ): Promise<void> {
    const provider = await this.getGitProvider(pr.repository);

    // Check if PR is mergeable
    const mergeable = await provider.isPRMergeable(pr.repository, pr.number);

    if (!mergeable) {
      throw new Error('PR is not mergeable (conflicts or checks failing)');
    }

    // Check CI status
    const ciPassed = await this.checkCIStatus(pr);

    if (!ciPassed) {
      throw new Error('CI checks have not passed');
    }

    // Merge PR
    await provider.mergePullRequest(pr.repository, pr.number, strategy);

    // Post-merge actions
    await this.handlePRMerged(pr);
  }

  private async checkCIStatus(pr: PullRequest): Promise<boolean> {
    const provider = await this.getGitProvider(pr.repository);

    // Get status checks
    const checks = await provider.getStatusChecks(pr.repository, pr.headSha);

    // All required checks must pass
    const requiredChecks = checks.filter(c => c.required);
    return requiredChecks.every(c => c.state === 'success');
  }

  private async handlePRMerged(pr: PullRequest): Promise<void> {
    const provider = await this.getGitProvider(pr.repository);

    // 1. Delete branch (if configured)
    const config = await this.getPRConfig(pr.repository);

    if (config.deleteBranchOnMerge) {
      await provider.deleteBranch(pr.repository, pr.head);
    }

    // 2. Track success
    await this.trackPRSuccess(pr);

    // 3. Notify stakeholders
    await this.notifyPRMerged(pr);

    // 4. Trigger post-merge analysis (measure impact)
    await this.triggerPostMergeAnalysis(pr);
  }

  private async trackPRSuccess(pr: PullRequest): Promise<void> {
    await this.db.transformations.update({
      where: { pullRequestId: pr.id },
      data: {
        status: 'MERGED',
        mergedAt: new Date(),
      },
    });

    // Update customer metrics
    await this.analytics.track('pr_merged', {
      customerId: pr.repository.customerId,
      transformationType: pr.metadata.transformationType,
      improvementScore: pr.metadata.scoreImprovement,
    });
  }
}
```

### Core Component 4: Notification System

```typescript
class PRNotificationService {
  async notifyReviewers(
    pr: PullRequest,
    channels: NotificationChannel[]
  ): Promise<void> {
    const reviewers = await this.getReviewers(pr);

    for (const channel of channels) {
      switch (channel) {
        case 'email':
          await this.sendEmailNotifications(pr, reviewers);
          break;
        case 'slack':
          await this.sendSlackNotifications(pr, reviewers);
          break;
        case 'teams':
          await this.sendTeamsNotifications(pr, reviewers);
          break;
        case 'discord':
          await this.sendDiscordNotifications(pr, reviewers);
          break;
      }
    }
  }

  private async sendEmailNotifications(
    pr: PullRequest,
    reviewers: Reviewer[]
  ): Promise<void> {
    for (const reviewer of reviewers) {
      await this.emailService.send({
        to: reviewer.email,
        subject: `Review Requested: ${pr.title}`,
        template: 'pr-review-request',
        data: {
          prTitle: pr.title,
          prUrl: pr.url,
          repository: pr.repository.fullName,
          summary: this.extractSummary(pr.body),
          metricsTable: this.extractMetricsTable(pr.body),
        },
      });
    }
  }

  private async sendSlackNotifications(
    pr: PullRequest,
    reviewers: Reviewer[]
  ): Promise<void> {
    const slackChannel = await this.getSlackChannel(pr.repository);

    await this.slackService.sendMessage({
      channel: slackChannel,
      blocks: [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `ü§ñ *Forge Factory: New PR Ready for Review*\n\n*${pr.title}*`,
          },
        },
        {
          type: 'section',
          fields: [
            {
              type: 'mrkdwn',
              text: `*Repository:*\n${pr.repository.fullName}`,
            },
            {
              type: 'mrkdwn',
              text: `*Reviewers:*\n${reviewers.map(r => `@${r.username}`).join(', ')}`,
            },
          ],
        },
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: this.extractSummary(pr.body),
          },
        },
        {
          type: 'actions',
          elements: [
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'View PR',
              },
              url: pr.url,
              style: 'primary',
            },
            {
              type: 'button',
              text: {
                type: 'plain_text',
                text: 'View Job Details',
              },
              url: this.getJobUrl(pr.metadata.transformationJobId),
            },
          ],
        },
      ],
    });
  }

  async notifyPRMerged(pr: PullRequest): Promise<void> {
    const config = await this.getPRConfig(pr.repository);

    if (config.notifyOnMerge) {
      await this.emailService.send({
        to: pr.author.email,
        subject: `PR Merged: ${pr.title}`,
        template: 'pr-merged',
        data: {
          prTitle: pr.title,
          prUrl: pr.url,
          repository: pr.repository.fullName,
          mergedBy: pr.mergedBy?.username,
          improvement: pr.metadata.scoreImprovement,
        },
      });
    }
  }
}
```

### Core Component 5: PR Configuration Management

```typescript
interface PRConfig {
  repositoryId: string;

  // Approval settings
  requiredApprovals: number; // 0 = auto-merge, 1+ = require approvals
  autoMergeEnabled: boolean;
  autoMergeStrategy: MergeStrategy;

  // Reviewers
  defaultReviewers: string[]; // GitHub usernames
  reviewerAssignmentStrategy: 'round-robin' | 'load-balanced' | 'manual';

  // Branch settings
  deleteBranchOnMerge: boolean;
  branchNamePrefix: string; // e.g., "forge-factory/"

  // Notifications
  notificationChannels: NotificationChannel[];
  notifyOnCreate: boolean;
  notifyOnMerge: boolean;

  // CI/CD integration
  waitForCIChecks: boolean;
  requiredCIChecks: string[]; // e.g., ["ci/circleci", "test-coverage"]

  // Advanced
  allowDraftPRs: boolean;
  addCodeComments: boolean;
  createStatusChecks: boolean;
}

class PRConfigManager {
  async getConfig(repository: Repository): Promise<PRConfig> {
    const stored = await this.db.prConfigs.findUnique({
      where: { repositoryId: repository.id },
    });

    if (stored) {
      return stored;
    }

    // Return defaults
    return this.getDefaultConfig(repository);
  }

  private getDefaultConfig(repository: Repository): PRConfig {
    return {
      repositoryId: repository.id,
      requiredApprovals: 1,
      autoMergeEnabled: false,
      autoMergeStrategy: MergeStrategy.SQUASH,
      defaultReviewers: [],
      reviewerAssignmentStrategy: 'manual',
      deleteBranchOnMerge: true,
      branchNamePrefix: 'forge-factory/',
      notificationChannels: ['email'],
      notifyOnCreate: true,
      notifyOnMerge: true,
      waitForCIChecks: true,
      requiredCIChecks: [],
      allowDraftPRs: true,
      addCodeComments: true,
      createStatusChecks: true,
    };
  }

  async updateConfig(
    repository: Repository,
    updates: Partial<PRConfig>
  ): Promise<PRConfig> {
    return await this.db.prConfigs.upsert({
      where: { repositoryId: repository.id },
      update: updates,
      create: {
        repositoryId: repository.id,
        ...this.getDefaultConfig(repository),
        ...updates,
      },
    });
  }
}
```

---

## Consequences

### Positive

1. **Transparency:** Developers see exactly what will change before merging
2. **Collaboration:** Team discussion on transformation approach
3. **Education:** Developers learn from AI-generated code
4. **Safety:** Human approval prevents risky changes
5. **Flexibility:** Configurable approval workflows fit different team sizes

### Negative

1. **Approval Bottleneck:** High-approval requirements slow down transformations
2. **Notification Fatigue:** Too many PRs can overwhelm teams
3. **Context Switching:** Developers must stop work to review PRs
4. **Complexity:** Managing approvals across 4+ Git providers

### Trade-offs

- **Automation vs. Control:** Auto-merge is fast but riskier; manual approval is safer but slower
- **Detail vs. Brevity:** Comprehensive PR descriptions are informative but long
- **Notifications vs. Noise:** Multiple channels ensure visibility but can annoy

---

## Implementation Plan

### Phase 1: PR Template Engine (Week 1-2)
- Implement template generation
- Build metrics table formatter
- Add test plan generator
- Create safety checks section

### Phase 2: PR Creation (Week 3-4)
- Integrate with Git provider abstraction
- Implement branch creation
- Add commit logic
- Test across GitHub, GitLab, Bitbucket

### Phase 3: Approval Workflow (Week 5-6)
- Build approval status checker
- Implement auto-merge logic
- Add CI status integration
- Test approval scenarios

### Phase 4: Notifications (Week 7)
- Implement email notifications
- Add Slack integration
- Add Microsoft Teams integration
- Test notification delivery

### Phase 5: Configuration (Week 8)
- Build PR config management
- Create configuration UI
- Add defaults and validation

### Phase 6: Testing & Polish (Week 9-10)
- End-to-end testing
- User acceptance testing
- Documentation
- Launch

---

## Alternatives Considered

### Alternative 1: Direct Merge (No PRs)
**Pros:** Fast, no approval overhead
**Cons:** No human review, risky, no discussion

### Alternative 2: Manual PR Creation (No Automation)
**Pros:** Full developer control
**Cons:** Slow, tedious, inconsistent descriptions

### Alternative 3: Email Patches (No Git Provider Integration)
**Pros:** Works without Git provider API access
**Cons:** No review UI, hard to track, poor UX

---

## References

- [GitHub Pull Request API](https://docs.github.com/en/rest/pulls)
- [GitLab Merge Request API](https://docs.gitlab.com/ee/api/merge_requests.html)
- [Conventional Commits](https://www.conventionalcommits.org/)
- [PR Best Practices](https://github.com/blog/2019-02-14-introducing-draft-pull-requests)
- [Code Review Guidelines](https://google.github.io/eng-practices/review/)

---

**Decision Maker:** CTO + Lead Architect
**Approved By:** Engineering + Product Leadership
**Implementation Owner:** Platform Engineering Team
